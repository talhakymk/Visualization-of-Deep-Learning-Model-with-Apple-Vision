//
//  ImmersiveView.swift
//  Visualization of DeepLearning
//
//  Created by Melike SEYİTOĞLU on 27.08.2025.
//

import SwiftUI
import RealityKit
import RealityKitContent

// Immersive alan içerisine olanlar
// Lenet: MainPanel, 2x2x6 filtre, 5x5x16 filtre

struct ImmersiveView: View {
    
    @Environment(AppModel.self) private var appModel
    
    @State private var cubeTapSubscription: EventSubscription? = nil
    @State private var shrunkCubes: Set<String> = []
        // Drag işlemi için initial position tracking (birden fazla panel için)
    @State private var detailPanelInitialPositions: [String: SIMD3<Float>] = [:]
    
    var body: some View {
        RealityView { content, attachments in
            if content.entities.isEmpty {
                // Setup common entities (MainPanel, HandPanel)
                setupCommonEntities(content, attachments)
                
                // Setup model-specific entities based on selected model
                switch appModel.selectedModel {
                case .lenet:
                    setupLenetEntities(content, attachments)
                case .alexnet:
                    setupAlexNetEntities(content, attachments)
                case .none:
                    break // No model-specific entities
                }
            }
        } update: { content, attachments in
                
                // 3) 5x5x16 büyük filtre
                let largeAnchor = Entity()
                largeAnchor.name = "LenetLargeFiltersAnchor"
                content.add(largeAnchor)
                if let largeEntity = attachments.entity(for: "lenetLargeFilters") {
                    largeEntity.name = "LenetLargeFiltersEntity"
                    largeAnchor.addChild(largeEntity)
                }
                var largeT = Transform()
                largeT.translation = SIMD3<Float>(x: 0.35, y: 2, z: -1.5)
                largeAnchor.transform = largeT
                
                // 4) Lenet Küpleri
                let lenetCubeAnchor = makeLenetCubesAnchor()
                var lenetCubesT = Transform()
                lenetCubesT.translation = SIMD3<Float>(x: 1.2, y: 1.0, z: -1.5)
                lenetCubeAnchor.transform = lenetCubesT
                lenetCubeAnchor.isEnabled = false
                content.add(lenetCubeAnchor)
                
                // 4.5) AlexNet Küpleri
                let alexnetCubeAnchor = makeAlexNetCubesAnchor()
                var alexnetCubesT = Transform()
                alexnetCubesT.translation = SIMD3<Float>(x: 1.2, y: 1.0, z: -1.5)
                alexnetCubeAnchor.transform = alexnetCubesT
                alexnetCubeAnchor.isEnabled = false
                content.add(alexnetCubeAnchor)
                
                // 4.6) AlexNet Neural Network Model (arka-sol küpün solunda)
                let alexnetNetworkAnchor = makeAlexNetNeuralNetworkAnchor()
                var alexnetNetworkT = Transform()
                // Yeni arka-sol küp pozisyonu: x=1.2+(-1.2)=0.0, z=-1.5+3.6=2.1
                // Ağ modelini arka-sol küpün daha soluna konumlandır: x=0.0-2.5=-2.5
                alexnetNetworkT.translation = SIMD3<Float>(x: -2.5, y: 1.2, z: 2.1)
                alexnetNetworkAnchor.transform = alexnetNetworkT
                alexnetNetworkAnchor.isEnabled = false
                content.add(alexnetNetworkAnchor)
                
                // 4.7) AlexNet Neural Network Connection Lines
                let alexnetConnectionsAnchor = makeAlexNetConnectionLines()
                var alexnetConnectionsT = Transform()
                // Nöronlarla aynı pozisyonda
                alexnetConnectionsT.translation = SIMD3<Float>(x: -2.5, y: 1.2, z: 2.1)
                alexnetConnectionsAnchor.transform = alexnetConnectionsT
                alexnetConnectionsAnchor.isEnabled = false
                content.add(alexnetConnectionsAnchor)
                
                // 4.8) AlexNet Neural Network Layer Labels
                let alexnetLabelsAnchor = makeAlexNetLayerLabels()
                var alexnetLabelsT = Transform()
                // Nöronlarla aynı pozisyonda
                alexnetLabelsT.translation = SIMD3<Float>(x: -2.5, y: 1.2, z: 2.1)
                alexnetLabelsAnchor.transform = alexnetLabelsT
                alexnetLabelsAnchor.isEnabled = false
                content.add(alexnetLabelsAnchor)
                
                // 4.9) AlexNet Prediction Panel (kullanıcının solunda)
                let alexnetPredictionAnchor = Entity()
                alexnetPredictionAnchor.name = "AlexNetPredictionPanelAnchor"
                if let predictionEntity = attachments.entity(for: "alexnetPredictionPanel") {
                    predictionEntity.name = "AlexNetPredictionPanelEntity"
                    alexnetPredictionAnchor.addChild(predictionEntity)
                }
                var alexnetPredictionT = Transform()
                // Kullanıcının solunda konumlandır ve kullanıcıya dönük yap
                alexnetPredictionT.translation = SIMD3<Float>(x: -2.0, y: 1.5, z: 0.0)
                // 90° sağa döndür (kullanıcıya dönük)
                alexnetPredictionT.rotation = simd_quatf(angle: Float.pi / 2, axis: SIMD3<Float>(0, 1, 0))
                alexnetPredictionAnchor.transform = alexnetPredictionT
                alexnetPredictionAnchor.isEnabled = false
                content.add(alexnetPredictionAnchor)
                
                // 5) Her küp için ayrı Lenet FeatureMap Galerisi anchor'ları
                // Küplerle aynı yatay düzende, küplerin üstünde
                let cubeSpacing: Float = 0.8
                let startX: Float = -((cubeSpacing * 3) / 2.0)
                let galleryYOffset: Float = 0.35  // Küplerin üstünde
                
                for i in 0..<4 {
                    let lenetGalleryAnchor = Entity()
                    lenetGalleryAnchor.name = "LenetFeatureGalleryAnchor_\(i)"
                    var lenetGalleryT = Transform()
                    
                    // Küplerle aynı x pozisyonu, üstte
                    let x = startX + Float(i) * cubeSpacing
                    lenetGalleryT.translation = SIMD3<Float>(x: 1.2 + x, y: 1.0 + galleryYOffset, z: -1.5)
                    lenetGalleryAnchor.transform = lenetGalleryT
                    lenetGalleryAnchor.isEnabled = false
                    content.add(lenetGalleryAnchor)
                }
                
                // 5.5) AlexNet Feature Map Gallery'leri (8 küp için)
                for i in 0..<8 {
                    let alexnetGalleryAnchor = Entity()
                    alexnetGalleryAnchor.name = "AlexNetFeatureGalleryAnchor_\(i)"
                    
                    if let galleryEntity = attachments.entity(for: "alexnetFeatureGallery_\(i)") {
                        galleryEntity.name = "AlexNetFeatureGalleryEntity_\(i)"
                        alexnetGalleryAnchor.addChild(galleryEntity)
                    }
                    
                    var alexnetGalleryT = Transform()
                    // AlexNet küplerinin üstünde konumlandır (küp pozisyonlarına göre)
                    // Büyük paneller için daha fazla Y offset (384 ve 256 grid panelleri için)
                    let alexnetGalleryYOffset: Float = 0.8
                    
                    // AlexNet küp pozisyonlarına göre gallery pozisyonları - arttırılmış mesafeler
                    let alexnetCubePositions: [SIMD3<Float>] = [
                        SIMD3<Float>(-1.2, 0, 0),    // Sol (arttırıldı)
                        SIMD3<Float>(0, 0, 0),       // Orta
                        SIMD3<Float>(1.2, 0, 0),     // Sağ (arttırıldı)
                        SIMD3<Float>(2.4, 0, 1.2),  // Sağ-ön (arttırıldı)
                        SIMD3<Float>(2.4, 0, 2.4),  // Sağ-arka (arttırıldı)
                        SIMD3<Float>(-1.2, 0, 3.6), // Arka-sol (arttırıldı)
                        SIMD3<Float>(0, 0, 3.6),    // Arka-orta (arttırıldı)
                        SIMD3<Float>(1.2, 0, 3.6)   // Arka-sağ (arttırıldı)
                    ]
                    
                    let cubePos = alexnetCubePositions[i]
                    alexnetGalleryT.translation = SIMD3<Float>(
                        x: 1.2 + cubePos.x,
                        y: 1.0 + alexnetGalleryYOffset,
                        z: -1.5 + cubePos.z
                    )
                    
                    // Pozisyona göre rotasyon uygula (kullanıcıya dönük)
                    switch i {
                    case 3, 4: // Sağ taraftaki küpler (3: Sağ-ön, 4: Sağ-arka)
                        // 90° sol döndür (kullanıcıya baksın)
                        alexnetGalleryT.rotation = simd_quatf(angle: -Float.pi / 2, axis: SIMD3<Float>(0, 1, 0))
                    case 5, 6, 7: // Arka taraftaki küpler (5: Arka-sol, 6: Arka-orta, 7: Arka-sağ)
                        // 180° döndür (kullanıcıya baksın)
                        alexnetGalleryT.rotation = simd_quatf(angle: Float.pi, axis: SIMD3<Float>(0, 1, 0))
                    default: // Ön taraftaki küpler (0: Sol, 1: Orta) - rotasyon yok
                        break
                    }
                    
                    alexnetGalleryAnchor.transform = alexnetGalleryT
                    alexnetGalleryAnchor.isEnabled = false
                    content.add(alexnetGalleryAnchor)
                }
                
                // 6) Flatten Layer Visualization - Arkada, büyük ve merkezi
                let flattenAnchor = Entity()
                flattenAnchor.name = "FlattenLayerAnchor"
                content.add(flattenAnchor)
                if let flattenEntity = attachments.entity(for: "flattenLayer") {
                    flattenEntity.name = "FlattenLayerEntity"
                    flattenAnchor.addChild(flattenEntity)
                }
                var flattenT = Transform()
                flattenT.translation = SIMD3<Float>(x: 3.5, y: 1.2, z: -1.5) // Küplerden biraz daha uzak
                // flattenT.rotation = simd_quatf(angle: .pi, axis: SIMD3<Float>(0, 1, 0)) // Rotation kaldırıldı - kullanıcıya baksın
                flattenT.scale = SIMD3<Float>(repeating: 1.2) // Biraz daha küçük
                flattenAnchor.transform = flattenT
                flattenAnchor.isEnabled = false
                
                // 7) Dense Layer 1 Visualization - Flatten'in sağında
                let dense1Anchor = Entity()
                dense1Anchor.name = "Dense1LayerAnchor"
                content.add(dense1Anchor)
                if let dense1Entity = attachments.entity(for: "dense1Layer") {
                    dense1Entity.name = "Dense1LayerEntity"
                    dense1Anchor.addChild(dense1Entity)
                }
                var dense1T = Transform()
                dense1T.translation = SIMD3<Float>(x: 4.4, y: 1.2, z: -1.5) // Flatten'e daha yakın (1m mesafe)
                // dense1T.rotation = simd_quatf(angle: .pi, axis: SIMD3<Float>(0, 1, 0)) // Rotation kaldırıldı
                dense1T.scale = SIMD3<Float>(repeating: 1.2) // Biraz daha küçük
                dense1Anchor.transform = dense1T
                dense1Anchor.isEnabled = false
                
                // 8) Dense Layer 2 Visualization - Dense1'in sağında
                let dense2Anchor = Entity()
                dense2Anchor.name = "Dense2LayerAnchor"
                content.add(dense2Anchor)
                if let dense2Entity = attachments.entity(for: "dense2Layer") {
                    dense2Entity.name = "Dense2LayerEntity"
                    dense2Anchor.addChild(dense2Entity)
                }
                var dense2T = Transform()
                dense2T.translation = SIMD3<Float>(x: 5.1, y: 1.2, z: -1.5) // Dense1'e çok daha yakın (0.3m mesafe)
                // dense2T.rotation = simd_quatf(angle: .pi, axis: SIMD3<Float>(0, 1, 0)) // Rotation kaldırıldı
                dense2T.scale = SIMD3<Float>(repeating: 1.2) // Biraz daha küçük
                dense2Anchor.transform = dense2T
                dense2Anchor.isEnabled = false
                
                // 9) Output Layer Visualization - Dense2'nin sağında (final output)
                let outputAnchor = Entity()
                outputAnchor.name = "OutputLayerAnchor"
                content.add(outputAnchor)
                if let outputEntity = attachments.entity(for: "outputLayer") {
                    outputEntity.name = "OutputLayerEntity"
                    outputAnchor.addChild(outputEntity)
                }
                var outputT = Transform()
                outputT.translation = SIMD3<Float>(x: 5.7, y: 1.2, z: -1.5) // Dense2'nin sağında (0.6m mesafe)
                outputT.scale = SIMD3<Float>(repeating: 1.0) // Normal boyut
                outputAnchor.transform = outputT
                outputAnchor.isEnabled = false
                
                // 10) Connection Lines Container - Nöron bağlantı çizgilerini tutacak
                let connectionAnchor = Entity()
                connectionAnchor.name = "ConnectionLinesAnchor"
                content.add(connectionAnchor)
                
            // Multiple Feature Map Detail Panels: Her panel için ayrı anchor
            for panel in appModel.openFeatureMapPanels {
                let detailPanelAnchor = Entity()
                detailPanelAnchor.name = "FeatureMapDetailPanelAnchor_\(panel.id)"
                
                // Aynı cube'den olan panel'lerin index'ini hesapla
                let sameCubePanels = appModel.openFeatureMapPanels.filter { $0.cubeIndex == panel.cubeIndex }
                let panelIndexInCube = sameCubePanels.firstIndex { $0.id == panel.id } ?? 0
                
                // Panel pozisyonunu seçilen cube'in grid hizasında konumlandır
                let panelPosition = calculateDetailPanelPosition(
                    cubeIndex: panel.cubeIndex,
                    panelIndex: panelIndexInCube,
                    totalPanelsForCube: sameCubePanels.count
                )
                detailPanelAnchor.position = panelPosition
                
                // Panel rotasyonunu cube pozisyonuna göre ayarla (kullanıcıya dönük)
                let panelRotation = calculateDetailPanelRotation(cubeIndex: panel.cubeIndex)
                detailPanelAnchor.orientation = panelRotation
                
                content.add(detailPanelAnchor)
            }
            }
        } update: { content, attachments in
            // Main Panel: Her zaman göster ama sadece durumu değiştiğinde güncelle (stability için)
            if let mainPanelAnchor = content.entities.first(where: { $0.name == "MainPanelAnchor" }) {
                mainPanelAnchor.isEnabled = true // Her zaman aktif
                
                // Main panel attachment'ını sadece boşsa ekle (stability için)
                if mainPanelAnchor.children.isEmpty {
                    if let mainPanelEntity = attachments.entity(for: "mainPanel") {
                        mainPanelEntity.name = "MainPanelAttachmentEntity"
                        mainPanelAnchor.addChild(mainPanelEntity)
                    }
                }
            }
            
            // Küpler sadece LeNet + input seçiliyse görünsün
            if let cubes = content.entities.first(where: { $0.name == "LenetCubesAnchor" }) {
                let shouldShowCubes = (appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil)
                cubes.isEnabled = shouldShowCubes
            }
            
            // AlexNet küpler sadece AlexNet + input seçiliyse görünsün
            if let alexnetCubes = content.entities.first(where: { $0.name == "AlexNetCubesAnchor" }) {
                let shouldShowAlexNetCubes = (appModel.selectedModel == .alexnet && appModel.selectedInputImageName != nil)
                alexnetCubes.isEnabled = shouldShowAlexNetCubes
            }
            
            // AlexNet Neural Network sadece AlexNet + input seçiliyse görünsün
            if let alexnetNetwork = content.entities.first(where: { $0.name == "AlexNetNeuralNetworkAnchor" }) {
                let shouldShowAlexNetNetwork = (appModel.selectedModel == .alexnet && appModel.selectedInputImageName != nil)
                alexnetNetwork.isEnabled = shouldShowAlexNetNetwork
            }
            
            // AlexNet Neural Network Connections sadece AlexNet + input seçiliyse görünsün
            if let alexnetConnections = content.entities.first(where: { $0.name == "AlexNetConnectionLinesAnchor" }) {
                let shouldShowAlexNetConnections = (appModel.selectedModel == .alexnet && appModel.selectedInputImageName != nil)
                alexnetConnections.isEnabled = shouldShowAlexNetConnections
            }
            
            // AlexNet Neural Network Layer Labels sadece AlexNet + input seçiliyse görünsün
            if let alexnetLabels = content.entities.first(where: { $0.name == "AlexNetLayerLabelsAnchor" }) {
                let shouldShowAlexNetLabels = (appModel.selectedModel == .alexnet && appModel.selectedInputImageName != nil)
                alexnetLabels.isEnabled = shouldShowAlexNetLabels
            }
            
            // AlexNet Prediction Panel sadece AlexNet + input seçiliyse görünsün
            if let alexnetPrediction = content.entities.first(where: { $0.name == "AlexNetPredictionPanelAnchor" }) {
                let shouldShowAlexNetPrediction = (appModel.selectedModel == .alexnet && appModel.selectedInputImageName != nil)
                alexnetPrediction.isEnabled = shouldShowAlexNetPrediction
            }
            
            // Her küp için ayrı galeri kontrolü (LeNet)
            for i in 0..<4 {
                if let gallery = content.entities.first(where: { $0.name == "LenetFeatureGalleryAnchor_\(i)" }) {
                    let shouldShowGallery = (appModel.selectedModel == .lenet && 
                                           appModel.selectedInputImageName != nil && 
                                           appModel.isCubeOpen(i))
                    gallery.isEnabled = shouldShowGallery
                    
                    // Galeri attachment'ını sadece durumu değiştiğinde güncelle (stability için)
                    if shouldShowGallery && gallery.children.isEmpty {
                        // Bu küp için attachment oluştur
                        if let galleryEntity = attachments.entity(for: "lenetFeatureGallery_\(i)") {
                            galleryEntity.name = "LenetFeatureGalleryEntity_\(i)"
                            gallery.addChild(galleryEntity)
                        }
                    }
                }
            }
            
            // AlexNet gallery kontrolü (8 küp için)
            for i in 0..<8 {
                if let alexnetGallery = content.entities.first(where: { $0.name == "AlexNetFeatureGalleryAnchor_\(i)" }) {
                    let shouldShowAlexNetGallery = (appModel.selectedModel == .alexnet && 
                                                   appModel.selectedInputImageName != nil && 
                                                   appModel.isAlexNetCubeOpen(i))
                    alexnetGallery.isEnabled = shouldShowAlexNetGallery
                    
                    // AlexNet galeri attachment'ını sadece durumu değiştiğinde güncelle (stability için)
                    if shouldShowAlexNetGallery && alexnetGallery.children.isEmpty {
                        // Bu AlexNet küpü için attachment oluştur
                        if let alexnetGalleryEntity = attachments.entity(for: "alexnetFeatureGallery_\(i)") {
                            alexnetGalleryEntity.name = "AlexNetFeatureGalleryEntity_\(i)"
                            alexnetGallery.addChild(alexnetGalleryEntity)
                        }
                    }
                }
            }
            
            // Flatten Layer: LeNet + input seçili olduğunda göster
            if let flatten = content.entities.first(where: { $0.name == "FlattenLayerAnchor" }) {
                let shouldShowFlatten = (appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil)
                flatten.isEnabled = shouldShowFlatten
                
                // Flatten attachment'ını sadece durumu değiştiğinde güncelle (stability için)
                if shouldShowFlatten && flatten.children.isEmpty {
                    if let flattenEntity = attachments.entity(for: "flattenLayer") {
                        flattenEntity.name = "FlattenLayerEntity"
                        flatten.addChild(flattenEntity)
                    }
                }
            }
            
            // Dense Layer 1: LeNet + input seçili olduğunda göster
            if let dense1 = content.entities.first(where: { $0.name == "Dense1LayerAnchor" }) {
                let shouldShowDense1 = (appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil)
                dense1.isEnabled = shouldShowDense1
                
                // Dense1 attachment'ını sadece durumu değiştiğinde güncelle (stability için)
                if shouldShowDense1 && dense1.children.isEmpty {
                    if let dense1Entity = attachments.entity(for: "dense1Layer") {
                        dense1Entity.name = "Dense1LayerEntity"
                        dense1.addChild(dense1Entity)
                    }
                }
            }
            
            // Dense Layer 2: LeNet + input seçili olduğunda göster
            if let dense2 = content.entities.first(where: { $0.name == "Dense2LayerAnchor" }) {
                let shouldShowDense2 = (appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil)
                dense2.isEnabled = shouldShowDense2
                
                // Dense2 attachment'ını sadece durumu değiştiğinde güncelle (stability için)
                if shouldShowDense2 && dense2.children.isEmpty {
                    if let dense2Entity = attachments.entity(for: "dense2Layer") {
                        dense2Entity.name = "Dense2LayerEntity"
                        dense2.addChild(dense2Entity)
                    }
                }
            }
            
            // Output Layer: LeNet + input seçili olduğunda göster
            if let output = content.entities.first(where: { $0.name == "OutputLayerAnchor" }) {
                let shouldShowOutput = (appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil)
                output.isEnabled = shouldShowOutput
                
                // Output attachment'ını sadece durumu değiştiğinde güncelle (stability için)
                if shouldShowOutput && output.children.isEmpty {
                    if let outputEntity = attachments.entity(for: "outputLayer") {
                        outputEntity.name = "OutputLayerEntity"
                        output.addChild(outputEntity)
                    }
                }
            }
            
            // Connection Lines: Nöron bağlantılarını güncelle (sadece LeNet için)
            if let connectionAnchor = content.entities.first(where: { $0.name == "ConnectionLinesAnchor" }) {
                // Önce mevcut tüm bağlantıları temizle
                connectionAnchor.children.removeAll()
                
                // Sadece LeNet seçiliyse ve aktif bağlantılar varsa çizgileri oluştur
                if appModel.selectedModel == .lenet && 
                   appModel.selectedInputImageName != nil &&
                   !appModel.activeConnections.isEmpty {
                    updateConnectionLines(connectionAnchor: connectionAnchor)
                }
            }
            
            // Multiple Feature Map Detail Panels: Her panel için ayrı yönetim
            let existingPanelAnchors = content.entities.filter { $0.name.hasPrefix("FeatureMapDetailPanelAnchor_") }
            let existingPanelIds = Set(existingPanelAnchors.compactMap { anchor in
                let components = anchor.name.split(separator: "_")
                return components.count >= 2 ? String(components.dropFirst().joined(separator: "_")) : nil
            })
            
            let activePanelIds = Set(appModel.openFeatureMapPanels.map { $0.id.uuidString })
            
            // Gereksiz panel anchor'larını kaldır
            for anchor in existingPanelAnchors {
                let components = anchor.name.split(separator: "_")
                if components.count >= 2 {
                    let panelIdStr = String(components.dropFirst().joined(separator: "_"))
                    if !activePanelIds.contains(panelIdStr) {
                        content.remove(anchor)
                    }
                }
            }
            
            // Eksik panel anchor'larını ekle
            for panel in appModel.openFeatureMapPanels {
                if !existingPanelIds.contains(panel.id.uuidString) {
                    let detailPanelAnchor = Entity()
                    detailPanelAnchor.name = "FeatureMapDetailPanelAnchor_\(panel.id)"
                    
                    // Aynı cube'den olan panel'lerin index'ini hesapla
                    let sameCubePanels = appModel.openFeatureMapPanels.filter { $0.cubeIndex == panel.cubeIndex }
                    let panelIndexInCube = sameCubePanels.firstIndex { $0.id == panel.id } ?? 0
                    
                    // Panel pozisyonunu seçilen cube'in grid hizasında konumlandır
                    let panelPosition = calculateDetailPanelPosition(
                        cubeIndex: panel.cubeIndex,
                        panelIndex: panelIndexInCube,
                        totalPanelsForCube: sameCubePanels.count
                    )
                    detailPanelAnchor.position = panelPosition
                    
                    // Panel rotasyonunu cube pozisyonuna göre ayarla (kullanıcıya dönük)
                    let panelRotation = calculateDetailPanelRotation(cubeIndex: panel.cubeIndex)
                    detailPanelAnchor.orientation = panelRotation
                    
                    content.add(detailPanelAnchor)
                }
            }
            
            // Her panel anchor için attachment güncelle
            for panel in appModel.openFeatureMapPanels {
                if let anchor = content.entities.first(where: { $0.name == "FeatureMapDetailPanelAnchor_\(panel.id)" }) {
                    // Attachment'ı sadece boşsa ekle
                    if anchor.children.isEmpty {
                        if let detailPanelEntity = attachments.entity(for: "featureMapDetailPanel_\(panel.id)") {
                            detailPanelEntity.name = "FeatureMapDetailPanelEntity_\(panel.id)"
                            
                            // Panel'e collision ve input components ekle - Sadece close button için
                            let panelSize: Float = 0.6
                            detailPanelEntity.components.set(CollisionComponent(shapes: [.generateBox(size: [panelSize, panelSize * 1.2, 0.01])]))
                            detailPanelEntity.components.set(InputTargetComponent(allowedInputTypes: [.indirect, .direct]))
                            detailPanelEntity.components.set(HoverEffectComponent())
                            
                            // Drag handle için ayrı entity (daha büyük alan)
                            let dragHandleEntity = Entity()
                            dragHandleEntity.name = "DragHandle_\(panel.id)"
                            dragHandleEntity.position = SIMD3<Float>(0, -0.17, 0.01) // Daha yukarıda
                            
                            // Drag handle collision (daha büyük alan - panelin alt yarısı)
                            let dragHandleWidth: Float = 0.35
                            let dragHandleHeight: Float = 0.1 // Daha yüksek
                            dragHandleEntity.components.set(CollisionComponent(shapes: [.generateBox(size: [dragHandleWidth, dragHandleHeight, 0.02])]))
                            dragHandleEntity.components.set(InputTargetComponent(allowedInputTypes: [.indirect, .direct]))
                            
                            // Close button için ayrı entity (üst sağ köşede)
                            let closeButtonEntity = Entity()
                            closeButtonEntity.name = "CloseButton_\(panel.id)"
                            closeButtonEntity.position = SIMD3<Float>(0.155, 0.195, 0.02) // Üst sağ köşe
                            
                            // Close button collision (büyük tap area)
                            let closeButtonSize: Float = 0.035 // Daha büyük area
                            closeButtonEntity.components.set(CollisionComponent(shapes: [.generateBox(size: [closeButtonSize, closeButtonSize, 0.03])]))
                            closeButtonEntity.components.set(InputTargetComponent(allowedInputTypes: [.indirect, .direct]))
                            closeButtonEntity.components.set(HoverEffectComponent())
                            
                            detailPanelEntity.addChild(dragHandleEntity)
                            detailPanelEntity.addChild(closeButtonEntity)
                            anchor.addChild(detailPanelEntity)
                        }
                    }
                }
            }
        } attachments: {
            // MainPanel içeriği
            Attachment(id: "mainPanel") {
                MainPanelView()
                    .padding(.horizontal, 24)
                    .frame(width: 600, height: 1700)
                    .background(Color.blue, in: .rect(cornerRadius: 16))
            }
            
            // 2x2x6 panel içeriği
            Attachment(id: "lenetSmallFilters") {
                Group {
                    if appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil{
                        LenetSmallFiltersPanel(onTap: { _ in /* opsiyonel */ })
                    } else {
                        EmptyView()
                    }
                }
            }
            
            // 5x5x16 panel içeriği
            Attachment(id: "lenetLargeFilters") {
                Group {
                    if appModel.selectedModel == .lenet && appModel.selectedInputImageName != nil{
                        LenetLargeFiltersPanel()
                    } else {
                        EmptyView()
                    }
                }
            }
            // Her küp için ayrı Lenet FeatureMap Galerisi
            ForEach(0..<4, id: \.self) { cubeIndex in
                Attachment(id: "lenetFeatureGallery_\(cubeIndex)") {
                    Group {
                        if let cfg = appModel.lenetFeatureMapConfigForCube(cubeIndex), appModel.isCubeOpen(cubeIndex) {
                            LenetFeatureMapGalleryView(images: cfg.images, columns: cfg.columns, rows: cfg.rows)
                        } else {
                            EmptyView()
                        }
                    }
                }
            }
            
            // Flatten Layer Visualization
            Attachment(id: "flattenLayer") {
                Group {
                    if let inputIndex = appModel.selectedInputIndex() {
                        FlattenVisualizationView(inputIndex: inputIndex)
                    } else {
                        EmptyView()
                    }
                }
            }
            
            // Dense Layer 1 Visualization
            Attachment(id: "dense1Layer") {
                Group {
                    if let inputIndex = appModel.selectedInputIndex() {
                        DenseVisualizationView(
                            inputIndex: inputIndex,
                            layerName: "DENSE LAYER 1",
                            layerType: "dense_1",
                            gridRows: 12,
                            gridCols: 10
                        )
                    } else {
                        EmptyView()
                    }
                }
            }
            
            // Dense Layer 2 Visualization
            Attachment(id: "dense2Layer") {
                Group {
                    if let inputIndex = appModel.selectedInputIndex() {
                        DenseVisualizationView(
                            inputIndex: inputIndex,
                            layerName: "DENSE LAYER 2",
                            layerType: "dense_2",
                            gridRows: 12,
                            gridCols: 7
                        )
                    } else {
                        EmptyView()
                    }
                }
            }
            
            // Output Layer Visualization
            Attachment(id: "outputLayer") {
                OutputVisualizationView(appModel: appModel)
            }
            
            // AlexNet Prediction Panel
            Attachment(id: "alexnetPredictionPanel") {
                AlexNetPredictionPanel(appModel: appModel)
            }
            
            // AlexNet Feature Map Gallery'leri (8 küp için)
            ForEach(0..<8, id: \.self) { cubeIndex in
                Attachment(id: "alexnetFeatureGallery_\(cubeIndex)") {
                    Group {
                        if let inputIndex = appModel.selectedInputIndex() {
                            AlexNetFeatureMapGalleryView(
                                cubeIndex: cubeIndex, 
                                inputIndex: inputIndex,
                                selectedInputName: appModel.selectedInputImageName
                            ) { cubeIdx, featureMapIdx in
                                // Feature map detail panel'i aç
                                appModel.openFeatureMapDetailPanel(
                                    cubeIndex: cubeIdx, 
                                    featureMapIndex: featureMapIdx
                                )
                            }
                        } else {
                            EmptyView()
                        }
                    }
                }
            }
            
            // Multiple Feature Map Detail Panels (hareket ettirilebilen)
            ForEach(appModel.openFeatureMapPanels, id: \.id) { panel in
                Attachment(id: "featureMapDetailPanel_\(panel.id)") {
                    FeatureMapDetailPanel(
                        cubeIndex: panel.cubeIndex,
                        featureMapIndex: panel.featureMapIndex,
                        inputIndex: appModel.selectedInputIndex() ?? 0,
                        selectedInputName: appModel.selectedInputImageName
                    ) {
                        appModel.closeFeatureMapDetailPanel(id: panel.id)
                    }
                }
            }
        }
        // dokunulan küplerin küçülmesi + panel işlemleri
        .gesture(
            SpatialTapGesture()
                .targetedToAnyEntity()
                .onEnded { value in
                    let tapped = value.entity
                    
                    // Close Button Entity tapped - Direkt panel kapat
                    if tapped.name.hasPrefix("CloseButton_") {
                        let entityName = tapped.name
                        let panelIdStr = String(entityName.dropFirst("CloseButton_".count))
                        if let panelId = UUID(uuidString: panelIdStr) {
                            appModel.closeFeatureMapDetailPanel(id: panelId)
                        }
                        return // Exit early
                    }
                    
                    // Feature Map Detail Panel tapped - Close button kontrol et
                    if tapped.name.hasPrefix("FeatureMapDetailPanelEntity_") {
                        let entityName = tapped.name
                        let panelIdStr = String(entityName.dropFirst("FeatureMapDetailPanelEntity_".count))
                        
                        // Panel'deki tap position'ını kontrol et (close button alanında mı?)
                        let tapPosition = value.location3D
                        
                        // Close button'un panel üst sağında olduğunu varsay
                        // Panel size: 0.6 x 0.72, close button: sağ üst köşe
                        if tapPosition.x > 0.2 && tapPosition.y > 0.25 {
                            if let panelId = UUID(uuidString: panelIdStr) {
                                appModel.closeFeatureMapDetailPanel(id: panelId)
                            }
                            return // Exit early to prevent other gesture handling
                        }
                    }
                    
                    // LeNet küpleri
                    if tapped.name.hasPrefix("LenetCube_") {
                        if let idxStr = tapped.name.split(separator: "_").last, let idx = Int(idxStr) {
                            // Küpün durumunu değiştir (açık/kapalı)
                            appModel.toggleCube(idx)
                            
                            // Küpün görsel durumunu güncelle
                            var t = tapped.transform
                            if appModel.isCubeOpen(idx) {
                                t.scale = SIMD3<Float>(repeating: 0.25)  // küçük (açık)
                                shrunkCubes.insert(tapped.name)
                            } else {
                                t.scale = SIMD3<Float>(repeating: 1.0)   // orijinal (kapalı)
                                shrunkCubes.remove(tapped.name)
                            }
                            tapped.transform = t
                        }
                    }
                    
                    // AlexNet küpleri
                    else if tapped.name.hasPrefix("AlexNetCube_") {
                        if let idxStr = tapped.name.split(separator: "_").last, let idx = Int(idxStr) {
                            // Küpün durumunu değiştir (açık/kapalı)
                            appModel.toggleAlexNetCube(idx)
                            
                            // Küpün görsel durumunu güncelle
                            var t = tapped.transform
                            if appModel.isAlexNetCubeOpen(idx) {
                                t.scale = SIMD3<Float>(repeating: 0.25)  // küçük (açık)
                                shrunkCubes.insert(tapped.name)
                            } else {
                                t.scale = SIMD3<Float>(repeating: 1.0)   // orijinal (kapalı)
                                shrunkCubes.remove(tapped.name)
                            }
                            tapped.transform = t
                        }
                    }
                }
        )
        // Multiple Feature Map Detail Panels için drag gesture - Sadece drag handle'da
        .gesture(
            DragGesture()
                .targetedToAnyEntity()
                .onChanged { value in
                    // Sadece drag handle entity'si için çalış
                    guard value.entity.name.hasPrefix("DragHandle_") else { return }
                    
                    // Panel ID'sini drag handle'dan çıkar
                    let entityName = value.entity.name
                    let panelIdStr = String(entityName.dropFirst("DragHandle_".count))
                    
                    // Panel anchor'ını bul (drag handle -> panel entity -> panel anchor)
                    guard let panelEntity = value.entity.parent,
                          let detailPanelAnchor = panelEntity.parent else { return }
                    
                    // Drag logic
                    if detailPanelInitialPositions[panelIdStr] == nil {
                        detailPanelInitialPositions[panelIdStr] = detailPanelAnchor.transform.translation
                    }
                    guard let initialPos = detailPanelInitialPositions[panelIdStr] else { return }
                    
                    let translation = value.translation3D
                    let sensitivity: Float = 0.001
                    let scaledX = Float(translation.x) * sensitivity
                    let scaledY = -Float(translation.y) * sensitivity
                    let scaledZ = Float(translation.z) * sensitivity
                    
                    // Position kısıtlamaları kaldırıldı - Serbest hareket
                    let newX = initialPos.x + scaledX
                    let newY = initialPos.y + scaledY
                    let newZ = initialPos.z + scaledZ
                    
                    var newTransform = detailPanelAnchor.transform
                    newTransform.translation = SIMD3<Float>(newX, newY, newZ)
                    
                    // Rotation
                    let userPosition = SIMD3<Float>(0, 1.6, 0)
                    let panelPosition = newTransform.translation
                    let direction = normalize(userPosition - panelPosition)
                    let angle = atan2(direction.x, direction.z)
                    newTransform.rotation = simd_quatf(angle: angle, axis: SIMD3<Float>(0, 1, 0))
                    
                    detailPanelAnchor.transform = newTransform
                }
                .onEnded { value in
                    // Sadece drag handle entity'si için
                    guard value.entity.name.hasPrefix("DragHandle_") else { return }
                    
                    // Panel ID'sini çıkar ve initial position'ı temizle
                    let entityName = value.entity.name
                    let panelIdStr = String(entityName.dropFirst("DragHandle_".count))
                    detailPanelInitialPositions.removeValue(forKey: panelIdStr)
                }
        )
    }
    
    // Helper function: Connection line'ları oluştur
    private func updateConnectionLines(connectionAnchor: Entity) {
        guard let _ = appModel.selectedNeuronLayer,
              let _ = appModel.selectedNeuronIndex else { return }
        
        // Layer pozisyonları (ImmersiveView'deki pozisyonlarla eşleşmeli)
        let flattenPos = SIMD3<Float>(x: 3.5, y: 1.2, z: -1.5)
        let dense1Pos = SIMD3<Float>(x: 4.4, y: 1.2, z: -1.5)
        let dense2Pos = SIMD3<Float>(x: 5.15, y: 1.2, z: -1.5) // Dense1'e yakın
        let outputPos = SIMD3<Float>(x: 5.85, y: 1.2, z: -1.5)  // Dense2'nin sağında
        
        for connectionId in appModel.activeConnections {
            if let line = createConnectionLine(connectionId: connectionId, 
                                              flattenPos: flattenPos,
                                              dense1Pos: dense1Pos, 
                                              dense2Pos: dense2Pos,
                                              outputPos: outputPos) {
                connectionAnchor.addChild(line)
            }
        }
    }
    
    // Helper function: Sabit motif connection line oluştur
    private func createConnectionLine(connectionId: String, 
                                    flattenPos: SIMD3<Float>,
                                    dense1Pos: SIMD3<Float>, 
                                    dense2Pos: SIMD3<Float>,
                                    outputPos: SIMD3<Float>) -> Entity? {
        
        // Connection ID'yi parse et: "flatten12_to_dense1_fixed" 
        let parts = connectionId.split(separator: "_to_")
        guard parts.count == 2 else { return nil }
        
        let fromPart = String(parts[0]) // "flatten12"
        let toPart = String(parts[1])   // "dense1_fixed"
        
        // From position hesapla (seçilen neuron - gerçek grid position)
        var fromPos = SIMD3<Float>(0, 0, 0)
        var fromNeuronIndex = 0
        
        if fromPart.hasPrefix("flatten") {
            fromNeuronIndex = Int(fromPart.dropFirst("flatten".count)) ?? 0
            fromPos = calculateNeuronPosition(layer: "flatten", neuronIndex: fromNeuronIndex, layerPos: flattenPos)
        } else if fromPart.hasPrefix("dense1") {
            fromNeuronIndex = Int(fromPart.dropFirst("dense1".count)) ?? 0
            fromPos = calculateNeuronPosition(layer: "dense1", neuronIndex: fromNeuronIndex, layerPos: dense1Pos)
        } else if fromPart.hasPrefix("dense2") {
            fromNeuronIndex = Int(fromPart.dropFirst("dense2".count)) ?? 0
            fromPos = calculateNeuronPosition(layer: "dense2", neuronIndex: fromNeuronIndex, layerPos: dense2Pos)
        }
        
        // To position hesapla - SABİT YELPAZE PATTERN (grid pozisyonundan bağımsız)
        var toPos = SIMD3<Float>(0, 0, 0)
        var toNeuronIndex = 0
        
        if toPart.hasPrefix("dense1") {
            toNeuronIndex = Int(toPart.dropFirst("dense1".count)) ?? 0
            // SABİT YELPAZE: dense1 layer center'dan sabit pattern çıkar (flatten→dense1: geniş yelpaze)
            toPos = calculateFixedFanPosition(targetIndex: toNeuronIndex, totalTargets: 120, layerPos: dense1Pos, targetLayer: "dense1")
        } else if toPart.hasPrefix("dense2") {
            toNeuronIndex = Int(toPart.dropFirst("dense2".count)) ?? 0
            // SABİT YELPAZE: dense2 layer center'dan sabit pattern çıkar (dense1→dense2: dar yelpaze)
            toPos = calculateFixedFanPosition(targetIndex: toNeuronIndex, totalTargets: 84, layerPos: dense2Pos, targetLayer: "dense2")
        } else if toPart.hasPrefix("output") {
            toNeuronIndex = Int(toPart.dropFirst("output".count)) ?? 0
            // SABİT YELPAZE: output layer center'dan sabit pattern çıkar (dense2→output: çok dar yelpaze, 10 output)
            toPos = calculateFixedFanPosition(targetIndex: toNeuronIndex, totalTargets: 10, layerPos: outputPos, targetLayer: "output")
        }
        
        // Çizgi entity'si oluştur
        return createLineBetweenPoints(from: fromPos, to: toPos, connectionId: connectionId)
    }
    
    // Helper function: Nöron pozisyonunu hesapla (layer içindeki grid pozisyonu)
    private func calculateNeuronPosition(layer: String, neuronIndex: Int, layerPos: SIMD3<Float>) -> SIMD3<Float> {
        var neuronPos = layerPos
        
        // Grid boyutları
        let (rows, cols) = getLayerGridDimensions(layer: layer)
        
        // Nöron index'ten row/col hesapla
        let row = neuronIndex / cols
        let col = neuronIndex % cols
        
        // SwiftUI'da 700 points, scale factor güncellenmiş
        let baseImageSize: Float = 0.47  // Çok daha küçük base size (debug için)
        let scaleFactor: Float = 1.2    // Scale factor azalt (1.2 → 1.0)
        let actualImageSize = baseImageSize * scaleFactor
        
        // Dense layer'lar için aspect ratio düzeltmesi
        var actualWidth = actualImageSize
        var actualHeight = actualImageSize
        
        if layer.hasPrefix("dense") {
            let aspectRatio = Float(cols) / Float(rows)
            if aspectRatio > 1 {
                // Daha geniş (landscape)
                actualHeight = actualImageSize / aspectRatio
            } else {
                // Daha dar (portrait)  
                actualWidth = actualImageSize * aspectRatio
            }
        }
        
        let cellWidth = actualWidth / Float(cols)
        let cellHeight = actualHeight / Float(rows)
        
        // Grid offset hesapla - EXACT cell center mapping
        // Problem: SwiftUI grid (0,0) = top-left corner, ama biz center istiyoruz
        
        // Cell center offset hesapla: cell'in left-edge'inden center'ına
        let cellCenterOffsetX = cellWidth / 2.0
        let cellCenterOffsetY = cellHeight / 2.0
        
        // Grid'in sol-üst köşesinden offset hesapla
        let gridLeftEdge = -actualWidth / 2.0   // Grid'in sol kenarı
        let gridTopEdge = actualHeight / 2.0    // Grid'in üst kenarı
        
        // Seçilen cell'in center pozisyonunu hesapla
        let cellCenterX = gridLeftEdge + (Float(col) * cellWidth) + cellCenterOffsetX
        let cellCenterY = gridTopEdge - (Float(row) * cellHeight) - cellCenterOffsetY
        
        // Direct absolute position kullan (relative offset değil)
        neuronPos.x += cellCenterX
        neuronPos.y += cellCenterY
        
        return neuronPos
    }
    
    // Helper function: Compact neuron position (dar yelpaze için)
    private func calculateCompactNeuronPosition(layer: String, neuronIndex: Int, layerPos: SIMD3<Float>, scale: Float) -> SIMD3<Float> {
        var neuronPos = layerPos
        
        // Grid boyutları
        let (rows, cols) = getLayerGridDimensions(layer: layer)
        
        // Nöron index'ten row/col hesapla
        let row = neuronIndex / cols
        let col = neuronIndex % cols
        
        // Compact size - çok daha küçük alan (dar yelpaze için)
        let baseImageSize: Float = 0.3 * scale  // Scale factor ile dar yelpaze
        let scaleFactor: Float = 1.0
        let actualImageSize = baseImageSize * scaleFactor
        
        // Dense layer'lar için aspect ratio düzeltmesi
        var actualWidth = actualImageSize
        var actualHeight = actualImageSize
        
        if layer.hasPrefix("dense") {
            let aspectRatio = Float(cols) / Float(rows)
            if aspectRatio > 1 {
                // Landscape: height küçült
                actualHeight = actualImageSize / aspectRatio
            } else {
                // Portrait: width küçült
                actualWidth = actualImageSize * aspectRatio
            }
        }
        
        let cellWidth = actualWidth / Float(cols)
        let cellHeight = actualHeight / Float(rows)
        
        // Compact grid offset hesapla
        let gridLeftEdge = -actualWidth / 2.0
        let gridTopEdge = actualHeight / 2.0
        
        let cellCenterOffsetX = cellWidth / 2.0
        let cellCenterOffsetY = cellHeight / 2.0
        
        let cellCenterX = gridLeftEdge + (Float(col) * cellWidth) + cellCenterOffsetX
        let cellCenterY = gridTopEdge - (Float(row) * cellHeight) - cellCenterOffsetY
        
        // Compact position
        neuronPos.x += cellCenterX
        neuronPos.y += cellCenterY
        
        return neuronPos
    }
    
    // Helper function: SABİT YELPAZE pozisyonu (hangi grid seçerse seçsin aynı pattern)
    private func calculateFixedFanPosition(targetIndex: Int, totalTargets: Int, layerPos: SIMD3<Float>, targetLayer: String) -> SIMD3<Float> {
        var fanPos = layerPos
        
        // Layer'a göre farklı yelpaze parametreleri
        let fanHeight: Float
        if targetLayer == "dense1" {
            // Flatten → Dense1: Geniş yelpaze
            fanHeight = 0.45
        } else if targetLayer == "dense2" {
            // Dense1 → Dense2: Dar yelpaze
            fanHeight = 0.3
        } else if targetLayer == "output" {
            // Dense2 → Output: Çok dar yelpaze (sadece 10 output)
            fanHeight = 0.15
        } else {
            // Default
            fanHeight = 0.5
        }
        
        let fanDistance: Float = -0.2  // Layer'ın önüne (negatif = sol tarafa)
        
        // Target index'i normalize et (0.0 - 1.0 arasında)
        let normalizedIndex = Float(targetIndex) / Float(totalTargets - 1)
        
        // Sabit yelpaze pattern hesapla (layer center'dan)
        let fanX = fanDistance  // Sol tarafa doğru (layer'ın önü)
        let fanY = (normalizedIndex - 0.5) * fanHeight  // -fanHeight/2 den +fanHeight/2 ye
        
        // Sabit pattern uygula
        fanPos.x += fanX
        fanPos.y += fanY
        
        return fanPos
    }
    
    // Helper function: Layer grid boyutlarını döndür
    private func getLayerGridDimensions(layer: String) -> (rows: Int, cols: Int) {
        switch layer {
        case "flatten":
            return (16, 16) // 256 neurons
        case "dense1":
            return (12, 10) // 120 neurons
        case "dense2":
            return (12, 7)  // 84 neurons
        default:
            return (1, 1)
        }
    }
    
    // Helper function: 2D Line (Ultra-thin Box) - Hedef layer'a ulaşan çizgiler
    private func createLineBetweenPoints(from: SIMD3<Float>, to: SIMD3<Float>, connectionId: String) -> Entity {
        let lineEntity = Entity()
        lineEntity.name = "ConnectionLine_\(connectionId)"
        
        // Gerçek mesafeyi hesapla (from → to arası tam uzunluk)
        let realDistance = distance(from, to)
        let lineThickness: Float = 0.0002  // Biraz daha kalın (görünür olsun)
        
        // Ultra-thin box mesh (gerçek uzunlukta line)
        let boxMesh = MeshResource.generateBox(
            width: lineThickness,     // X: ince
            height: lineThickness,    // Y: ince  
            depth: realDistance      // Z: gerçek from→to mesafesi
        )
        
        // Material (2D line görünümü)
        var material = UnlitMaterial(color: .cyan)
        material.blending = .transparent(opacity: 0.9) // Daha görünür
        
        // Model component ekle
        lineEntity.components.set(ModelComponent(mesh: boxMesh, materials: [material]))
        
        // Pozisyon: from ve to noktaları arasındaki tam orta nokta
        let midPoint = (from + to) / 2
        lineEntity.position = midPoint
        
        // Orientation: Box Z-axis'ini from→to direction'ına align et
        let direction = normalize(to - from)
        let quaternion = simd_quatf(from: SIMD3<Float>(0, 0, 1), to: direction)
        lineEntity.orientation = quaternion
        
        return lineEntity
    }
    
    // Helper function: Detail panel pozisyonunu cube pozisyonuna göre hesapla
    private func calculateDetailPanelPosition(cubeIndex: Int, panelIndex: Int, totalPanelsForCube: Int) -> SIMD3<Float> {
        // AlexNet küp pozisyonları (ImmersiveView'daki ile aynı)
        let alexnetCubePositions: [SIMD3<Float>] = [
            SIMD3<Float>(-1.2, 0, 0),    // 0: Sol (conv1)
            SIMD3<Float>(0, 0, 0),       // 1: Orta (maxp1)
            SIMD3<Float>(1.2, 0, 0),     // 2: Sağ (conv2)
            SIMD3<Float>(2.4, 0, 1.2),  // 3: Sağ-ön (maxp2)
            SIMD3<Float>(2.4, 0, 2.4),  // 4: Sağ-arka (conv3)
            SIMD3<Float>(-1.2, 0, 3.6), // 5: Arka-sol (conv4)
            SIMD3<Float>(0, 0, 3.6),    // 6: Arka-orta (conv5)
            SIMD3<Float>(1.2, 0, 3.6)   // 7: Arka-sağ (maxp3)
        ]
        
        // Base anchor position (küplerle aynı base)
        let baseAnchorPos = SIMD3<Float>(x: 1.2, y: 1.0, z: -1.5)
        
        // Gallery Y offset (grid'lerle aynı yükseklik)
        let alexnetGalleryYOffset: Float = 0.8
        
        // Seçilen cube'in pozisyonu
        guard cubeIndex < alexnetCubePositions.count else {
            return SIMD3<Float>(0, baseAnchorPos.y + alexnetGalleryYOffset, -1.5) // Fallback position
        }
        
        let cubeRelativePos = alexnetCubePositions[cubeIndex]
        let galleryAbsolutePos = SIMD3<Float>(
            x: baseAnchorPos.x + cubeRelativePos.x,
            y: baseAnchorPos.y + alexnetGalleryYOffset, // Grid ile aynı yükseklik
            z: baseAnchorPos.z + cubeRelativePos.z
        )
        
        // Panel pozisyonu: Grid hizasında ve önünde
        let panelYOffset: Float = 0.0   // Grid ile aynı hizda
        
        // Z offset'i cube pozisyonuna göre ayarla
        let panelZOffset: Float
        switch cubeIndex {
        case 0, 1, 2: // Ön taraftaki küpler (Conv1, MaxP1, Conv2)
            panelZOffset = 0.0  // Daha çok öne (kullanıcıya yakın)
        case 3, 4: // Sağ taraftaki küpler (MaxP2, Conv3)
            panelZOffset = -0.5  // Orta mesafe
        case 5, 6, 7: // Arka taraftaki küpler (Conv4, Conv5, MaxP3)
            panelZOffset = -0.3  // Az öne (grid'in hemen önü)
        default:
            panelZOffset = -0.5  // Default
        }
        
        // Aynı cube'den birden fazla panel varsa yan yana diz
        let panelSpacing: Float = 0.7
        let totalWidth = Float(totalPanelsForCube - 1) * panelSpacing
        let startX = galleryAbsolutePos.x - (totalWidth / 2.0)
        let panelX = startX + (Float(panelIndex) * panelSpacing)
        
        return SIMD3<Float>(
            x: panelX,
            y: galleryAbsolutePos.y + panelYOffset,
            z: galleryAbsolutePos.z + panelZOffset
        )
    }
    
    // Helper function: Detail panel rotasyonunu cube pozisyonuna göre hesapla
    private func calculateDetailPanelRotation(cubeIndex: Int) -> simd_quatf {
        // Cube pozisyonuna göre kullanıcıya dönük rotasyon
        switch cubeIndex {
        case 3, 4: // Sağ taraftaki küpler (3: Sağ-ön, 4: Sağ-arka)
            // 90° sol döndür (kullanıcıya baksın)
            return simd_quatf(angle: -Float.pi / 2, axis: SIMD3<Float>(0, 1, 0))
        case 5, 6, 7: // Arka taraftaki küpler (5: Arka-sol, 6: Arka-orta, 7: Arka-sağ)
            // 180° döndür (kullanıcıya baksın)
            return simd_quatf(angle: Float.pi, axis: SIMD3<Float>(0, 1, 0))
        default: // Ön taraftaki küpler (0: Sol, 1: Orta, 2: Sağ) - rotasyon yok
            return simd_quatf(angle: 0, axis: SIMD3<Float>(0, 1, 0))
        }
    }
    
    // MARK: - Entity Setup Functions
    
    /// Setup common entities that are always present (MainPanel, HandPanel)
    private func setupCommonEntities(_ content: RealityViewContent, _ attachments: RealityViewAttachments) {
        // 1) Main Panel Anchor
        let mainAnchor = Entity()
        mainAnchor.name = "MainPanelAnchor"
        content.add(mainAnchor)
        // Panelin sabit konumu (sol-önde, göz hizası civarı)
        var mainT = Transform()
        mainT.translation = SIMD3<Float>(x: -0.6, y: 1.50, z: -1.5)
        mainAnchor.transform = mainT
        
        // Add any other common entities here if needed
    }
    
    /// Setup LeNet-specific entities
    private func setupLenetEntities(_ content: RealityViewContent, _ attachments: RealityViewAttachments) {
        // 2) 2x2x6 küçük filre
        let smallAnchor = Entity()
        smallAnchor.name = "LenetSmallFiltersAnchor"
        content.add(smallAnchor)
        if let smallEntity = attachments.entity(for: "lenetSmallFilters") {
            smallEntity.name = "LenetSmallFiltersEntity"
            smallAnchor.addChild(smallEntity)
        }
        var smallT = Transform()
        smallT.translation = SIMD3<Float>(x: -0.1, y: 2.0, z: -1.5)
        smallAnchor.transform = smallT
        
        // 3) 5x5x16 büyük filtre
        let largeAnchor = Entity()
        largeAnchor.name = "LenetLargeFiltersAnchor"
        content.add(largeAnchor)
        if let largeEntity = attachments.entity(for: "lenetLargeFilters") {
            largeEntity.name = "LenetLargeFiltersEntity"
            largeAnchor.addChild(largeEntity)
        }
        var largeT = Transform()
        largeT.translation = SIMD3<Float>(x: 0.35, y: 2, z: -1.5)
        largeAnchor.transform = largeT
        
        // 4) Lenet Küpleri
        let lenetCubeAnchor = makeLenetCubesAnchor()
        var lenetCubesT = Transform()
        lenetCubesT.translation = SIMD3<Float>(x: 1.2, y: 1.0, z: -1.5)
        lenetCubeAnchor.transform = lenetCubesT
        lenetCubeAnchor.isEnabled = false
        content.add(lenetCubeAnchor)
        
        // 5) Her küp için ayrı Lenet FeatureMap Galerisi anchor'ları
        // Küplerle aynı yatay düzende, küplerin üstünde
        let cubeSpacing: Float = 0.8
        let startX: Float = -((cubeSpacing * 3) / 2.0)
        let galleryYOffset: Float = 0.35  // Küplerin üstünde
        
        for i in 0..<4 {
            let lenetGalleryAnchor = Entity()
            lenetGalleryAnchor.name = "LenetFeatureGalleryAnchor_\(i)"
            var lenetGalleryT = Transform()
            
            // Küplerle aynı x pozisyonu, üstte
            let x = startX + Float(i) * cubeSpacing
            lenetGalleryT.translation = SIMD3<Float>(x: 1.2 + x, y: 1.0 + galleryYOffset, z: -1.5)
            lenetGalleryAnchor.transform = lenetGalleryT
            lenetGalleryAnchor.isEnabled = false
            content.add(lenetGalleryAnchor)
        }
    }
    
    /// Setup AlexNet-specific entities
    private func setupAlexNetEntities(_ content: RealityViewContent, _ attachments: RealityViewAttachments) {
        // 4.5) AlexNet Küpleri
        let alexnetCubeAnchor = makeAlexNetCubesAnchor()
        var alexnetCubesT = Transform()
        alexnetCubesT.translation = SIMD3<Float>(x: 1.2, y: 1.0, z: -1.5)
        alexnetCubeAnchor.transform = alexnetCubesT
        alexnetCubeAnchor.isEnabled = false
        content.add(alexnetCubeAnchor)
        
        // 4.6) AlexNet Neural Network Model (arka-sol küpün solunda)
        let alexnetNetworkAnchor = makeAlexNetNeuralNetworkAnchor()
        var alexnetNetworkT = Transform()
        // Yeni arka-sol küp pozisyonu: x=1.2+(-1.2)=0.0, z=-1.5+3.6=2.1
        // Ağ modelini arka-sol küpün daha soluna konumlandır: x=0.0-2.5=-2.5
        alexnetNetworkT.translation = SIMD3<Float>(x: -2.5, y: 1.2, z: 2.1)
        alexnetNetworkAnchor.transform = alexnetNetworkT
        alexnetNetworkAnchor.isEnabled = false
        content.add(alexnetNetworkAnchor)
        
        // 4.7) AlexNet Neural Network Connection Lines
        let alexnetConnectionsAnchor = makeAlexNetConnectionLines()
        var alexnetConnectionsT = Transform()
        // Nöronlarla aynı pozisyonda
        alexnetConnectionsT.translation = SIMD3<Float>(x: -2.5, y: 1.2, z: 2.1)
        alexnetConnectionsAnchor.transform = alexnetConnectionsT
        alexnetConnectionsAnchor.isEnabled = false
        content.add(alexnetConnectionsAnchor)
        
        // 4.8) AlexNet Neural Network Layer Labels
        let alexnetLabelsAnchor = makeAlexNetLayerLabels()
        var alexnetLabelsT = Transform()
        // Nöronlarla aynı pozisyonda
        alexnetLabelsT.translation = SIMD3<Float>(x: -2.5, y: 1.2, z: 2.1)
        alexnetLabelsAnchor.transform = alexnetLabelsT
        alexnetLabelsAnchor.isEnabled = false
        content.add(alexnetLabelsAnchor)
        
        // 4.9) AlexNet Prediction Panel (kullanıcının solunda)
        let alexnetPredictionAnchor = Entity()
        alexnetPredictionAnchor.name = "AlexNetPredictionPanelAnchor"
        if let predictionEntity = attachments.entity(for: "alexnetPredictionPanel") {
            predictionEntity.name = "AlexNetPredictionPanelEntity"
            alexnetPredictionAnchor.addChild(predictionEntity)
        }
        var alexnetPredictionT = Transform()
        // Kullanıcının solunda konumlandır ve kullanıcıya dönük yap
        alexnetPredictionT.translation = SIMD3<Float>(x: -2.0, y: 1.5, z: 0.0)
        // 90° sağa döndür (kullanıcıya dönük)
        alexnetPredictionT.rotation = simd_quatf(angle: Float.pi / 2, axis: SIMD3<Float>(0, 1, 0))
        alexnetPredictionAnchor.transform = alexnetPredictionT
        alexnetPredictionAnchor.isEnabled = false
        content.add(alexnetPredictionAnchor)
        
        // 5.5) AlexNet Feature Map Gallery'leri (8 küp için)
        for i in 0..<8 {
            let alexnetGalleryAnchor = Entity()
            alexnetGalleryAnchor.name = "AlexNetFeatureGalleryAnchor_\(i)"
            
            if let galleryEntity = attachments.entity(for: "alexnetFeatureGallery_\(i)") {
                galleryEntity.name = "AlexNetFeatureGalleryEntity_\(i)"
                alexnetGalleryAnchor.addChild(galleryEntity)
            }
            
            var alexnetGalleryT = Transform()
            // AlexNet küplerinin üstünde konumlandır (küp pozisyonlarına göre)
            
            let cubePositions: [SIMD3<Float>] = [
                SIMD3<Float>(-1.2, 0, 0),     // 0: Sol-ön
                SIMD3<Float>(0, 0, 0),        // 1: Orta-ön
                SIMD3<Float>(1.2, 0, 0),      // 2: Sağ-ön
                SIMD3<Float>(1.2, 0, 1.8),    // 3: Sağ-arka
                SIMD3<Float>(0, 0, 1.8),      // 4: Orta-arka
                SIMD3<Float>(-1.2, 0, 1.8),   // 5: Sol-arka
                SIMD3<Float>(-1.2, 0, 3.6),   // 6: Arka-sol
                SIMD3<Float>(0, 0, 3.6)       // 7: Arka-orta
            ]
            
            let cubePos = cubePositions[i]
            let galleryYOffset: Float = 0.4
            alexnetGalleryT.translation = SIMD3<Float>(
                x: 1.2 + cubePos.x,
                y: 1.0 + galleryYOffset,
                z: -1.5 + cubePos.z
            )
            alexnetGalleryAnchor.transform = alexnetGalleryT
            alexnetGalleryAnchor.isEnabled = false
            content.add(alexnetGalleryAnchor)
        }
    }
}

    
#Preview(immersionStyle: .mixed) {
    ImmersiveView()
        .environment(AppModel())
}
